"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = exports.HttpStatusCode = exports.JSONParseError = exports.HttpContentTypeError = exports.HttpStatusError = exports.HttpClientError = exports.ResponseContentType = void 0;
const Utils_1 = require("./Utils");
const Logger_1 = require("./Logger");
var ResponseContentType;
(function (ResponseContentType) {
    ResponseContentType["json"] = "application/json";
    ResponseContentType["text"] = "text/plain";
})(ResponseContentType = exports.ResponseContentType || (exports.ResponseContentType = {}));
class HttpClientError extends Error {
}
exports.HttpClientError = HttpClientError;
class HttpStatusError extends HttpClientError {
    constructor({ statusMessage, statusCode }) {
        super(statusMessage);
        this.statusMessage = statusMessage;
        this.statusCode = statusCode;
    }
}
exports.HttpStatusError = HttpStatusError;
class HttpContentTypeError extends HttpClientError {
    constructor(statusMessage, contentType) {
        super(statusMessage);
        this.statusMessage = statusMessage;
        this.contentType = contentType;
    }
}
exports.HttpContentTypeError = HttpContentTypeError;
class JSONParseError extends Error {
    constructor(message, responseBody) {
        super(message);
        this.message = message;
        this.responseBody = responseBody;
    }
}
exports.JSONParseError = JSONParseError;
var HttpStatusCode;
(function (HttpStatusCode) {
    HttpStatusCode[HttpStatusCode["ServiceUnavailable"] = 503] = "ServiceUnavailable";
})(HttpStatusCode = exports.HttpStatusCode || (exports.HttpStatusCode = {}));
class HttpClient {
    constructor({ url, timeout, requestHeaders, }) {
        const { userAgent = '', contentType = 'application/json' } = requestHeaders || {};
        this.url = url;
        this.timeout = timeout;
        this.requestHeaders = {
            userAgent,
            contentType,
        };
    }
    post(method, data, cancellationController) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Utils_1.isNode) {
                yield this.netAgentUse();
            }
            return yield this.postJSON(method, data, cancellationController);
        });
    }
    createAgent() {
        return new Promise((resolve) => {
            (0, Logger_1.debugNet)('Try create agent instance');
            // require('http') or require('https') hide require call from browser bundler, e.g. webpack
            const requester = module[`require`].call(module, this.url.protocol === 'https:' ? 'https' : 'http');
            this._agent = new requester.Agent({ keepAlive: true, timeout: this.timeout });
            resolve();
        });
    }
    netAgentUse() {
        if (this._agent) {
            (0, Logger_1.debugNet)('Reuse agent instance');
            return Promise.resolve();
        }
        return this.createAgent();
    }
    responseStatusHandler(res, expectedStatus) {
        return new Promise((resolve, reject) => {
            let statusCode;
            let statusMessage;
            if (Utils_1.isNode) {
                statusCode = res.statusCode;
                statusMessage = res.statusMessage;
            }
            else {
                statusCode = res.status;
                statusMessage = res.statusText;
            }
            if (statusCode === expectedStatus) {
                resolve(res);
            }
            else {
                reject(new HttpStatusError({ statusCode, statusMessage }));
            }
        });
    }
    responseContentTypeHandler(res, expectedContentTypes) {
        return new Promise((resolve, reject) => {
            let contentType;
            if (Utils_1.isNode) {
                contentType = res.headers['content-type'];
            }
            else {
                contentType = res.headers.get('Content-Type');
            }
            if (contentType) {
                if (Array.isArray(expectedContentTypes)
                    ? expectedContentTypes.some((expectedContentType) => contentType.includes(expectedContentType))
                    : contentType.includes(expectedContentTypes)) {
                    resolve(res);
                }
                else {
                    reject(new HttpContentTypeError(`Unexpected content type. Got ${contentType}`, contentType));
                }
            }
            else {
                reject(new HttpContentTypeError('Unknown content type', contentType));
            }
        });
    }
    responseBodyHandler(res) {
        return new Promise((resolve, reject) => {
            const chunks = [];
            res.on('data', (chunk) => chunks.push(chunk));
            res.on('end', () => {
                const responseBody = Buffer.concat(chunks).toString('utf8');
                (0, Logger_1.debugHttp)('Response body received', responseBody);
                resolve(responseBody);
            });
            res.on('error', reject);
        });
    }
    responseJSONHandler(res) {
        return __awaiter(this, void 0, void 0, function* () {
            let responseBody;
            try {
                if (Utils_1.isNode) {
                    responseBody = yield this.responseBodyHandler(res);
                    return JSON.parse(responseBody);
                }
                else {
                    return res.json();
                }
            }
            catch (err) {
                if (err instanceof SyntaxError) {
                    throw new JSONParseError(err.message, responseBody);
                }
                throw new JSONParseError('Unknown JSON parse error', responseBody);
            }
        });
    }
    requestHandler(method, data, cancellationController) {
        return new Promise((resolve, reject) => {
            const headers = {
                'user-agent': this.requestHeaders.userAgent,
                'content-type': this.requestHeaders.contentType,
            };
            const options = {
                headers,
                method: 'POST',
                signal: cancellationController && cancellationController.signal,
            };
            if (Utils_1.isNode) {
                Object.assign(options, {
                    host: this.url.hostname,
                    port: this.url.port,
                    path: `/${method}`,
                    agent: this._agent,
                });
            }
            else {
                Object.assign(options, {
                    mode: 'cors',
                    body: data,
                });
            }
            (0, Logger_1.debugHttp)('Request options', options);
            (0, Logger_1.debugHttp)('Request body', data);
            if (Utils_1.isNode) {
                // require('http') or require('https') hide require call from browser bundler, e.g. webpack
                const requester = module[`require`].call(module, this.url.protocol === 'https:' ? 'https' : 'http');
                requester
                    .request(options, (res) => {
                    (0, Logger_1.debugHttp)('Response headers received', res.statusCode, res.statusMessage);
                    resolve(res);
                })
                    .on('error', (err) => {
                    (0, Logger_1.debugHttp)('Response error', err);
                    reject(err);
                })
                    .end(data);
            }
            else {
                fetch(`${this.url.href}${method}`, options)
                    .then((res) => resolve(res))
                    .catch(reject);
            }
        });
    }
    postJSON(method, data, cancellationController) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.requestHandler(method, data, cancellationController);
            yield this.responseStatusHandler(res, 200);
            yield this.responseContentTypeHandler(res, [ResponseContentType.json, ResponseContentType.text]);
            return yield this.responseJSONHandler(res);
        });
    }
}
exports.HttpClient = HttpClient;
